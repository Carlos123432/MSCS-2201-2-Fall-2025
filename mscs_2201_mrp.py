# -*- coding: utf-8 -*-
"""MSCS 2201 - MRP.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bI9Eu6O18VxQuepeCUE3d6pG376W3Ot8
"""

# Mini Research Project: Grad-CAM for CNN Interpretability

## **Author:** Carlos Mendez  **Course:** MSCS 2201 – Artificial Intelligence

## This notebook demonstrates how to use **Grad-CAM** (Gradient-weighted Class Activation Mapping) to generate visual explanations for a pretrained **ResNet50** image classification model.

#We will: Load a pretrained ResNet50 from `torchvision`, Implement Grad-CAM. Run Grad-CAM on example images. Visualize the original image, heatmap, and overlay.

!pip install torchvision matplotlib pillow

import torch
import torch.nn.functional as F
from torchvision import models, transforms
from PIL import Image
import matplotlib.pyplot as plt
import numpy as np

print("PyTorch version:", torch.__version__)

# Standard ImageNet preprocessing for ResNet
preprocess = transforms.Compose([
    transforms.Resize((224, 224)),
    transforms.ToTensor(),
    transforms.Normalize(
        mean=[0.485, 0.456, 0.406],
        std=[0.229, 0.224, 0.225]
    )
])

class GradCAM:
    def __init__(self, model, target_layer):
        """
        model: a CNN model (e.g., torchvision.models.resnet50)
        target_layer: name of the last conv layer (e.g., "layer4")
        """
        self.model = model
        self.model.eval()

        # Get the layer module by name
        self.target_layer = dict(self.model.named_modules())[target_layer]

        self.activations = None
        self.gradients = None

        # Forward hook: store activations
        def forward_hook(module, input, output):
            self.activations = output

        # Backward hook: store gradients
        def backward_hook(module, grad_in, grad_out):
            self.gradients = grad_out[0]

        self.target_layer.register_forward_hook(forward_hook)
        self.target_layer.register_backward_hook(backward_hook)

    def generate(self, input_tensor, class_idx=None):
        """
        input_tensor: shape (1, C, H, W)
        class_idx: target class index; if None, use predicted class.
        returns:
        - cam: Grad-CAM heatmap as numpy array in [0,1]
        - class_idx: index of the class used
        """
        # Forward pass
        output = self.model(input_tensor)

        # If no target class is provided, use the predicted one
        if class_idx is None:
            class_idx = output.argmax(dim=1).item()

        # Zero gradients
        self.model.zero_grad()

        # Backward w.r.t. target class score
        target = output[0, class_idx]
        target.backward()

        # activations: [B, C, H, W]
        # gradients: [B, C, H, W]
        gradients = self.gradients
        activations = self.activations

        # Global average pooling over H and W
        weights = gradients.mean(dim=(2, 3), keepdim=True)  # [B, C, 1, 1]

        # Weighted sum across channels
        cam = (weights * activations).sum(dim=1, keepdim=True)  # [B, 1, H, W]

        # Apply ReLU
        cam = F.relu(cam)

        # Remove batch and channel dims → [H, W]
        cam = cam[0, 0]

        # Normalize to [0,1]
        cam -= cam.min()
        if cam.max() != 0:
            cam /= cam.max()

        return cam.detach().cpu().numpy(), class_idx

# Load pretrained ResNet50
model = models.resnet50(weights=models.ResNet50_Weights.IMAGENET1K_V2)

# Send to device
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
model = model.to(device)

print("Using device:", device)

# Initialize Grad-CAM with the last convolution block "layer4"
gradcam = GradCAM(model, target_layer="layer4")

# Change this filename to your uploaded image
image_path = "/Clutter.jpg"   # for example "dog.jpg" or "car.jpg"

# Load and preprocess
img = Image.open(image_path).convert("RGB")
input_tensor = preprocess(img).unsqueeze(0).to(device)

plt.imshow(img)
plt.title("Input Image")
plt.axis("off")
plt.show()

cam, class_idx = gradcam.generate(input_tensor)
print("Target class index used for Grad-CAM:", class_idx)
print("CAM shape:", cam.shape)

# Resize CAM to match original image size
heatmap = np.uint8(255 * cam)
heatmap = Image.fromarray(heatmap).resize(img.size, Image.BILINEAR)
heatmap = np.array(heatmap)

plt.figure(figsize=(12, 4))

# Original
plt.subplot(1, 3, 1)
plt.title("Original")
plt.imshow(img)
plt.axis("off")

# Heatmap
plt.subplot(1, 3, 2)
plt.title("Grad-CAM Heatmap")
plt.imshow(heatmap, cmap="jet")
plt.axis("off")

# Overlay
plt.subplot(1, 3, 3)
plt.title("Overlay")
plt.imshow(img)
plt.imshow(heatmap, cmap="jet", alpha=0.5)
plt.axis("off")

plt.tight_layout()
plt.show()